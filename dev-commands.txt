------------------------------------------------------------------------------------
Some links of tech resource

    1) C++/Python/Java/Design Patterns
    http://www.bogotobogo.com/index.php
    2) Socket programming
    https://www.ibm.com/support/knowledgecenter/ssw_i5_54/rzab6/rzab6soxoverview.htm
    3) Using multicast
    https://www.ibm.com/support/knowledgecenter/ssw_i5_54/rzab6/xmulticast.htm
    4) QuickFix - open source lib for FIX protocol
    http://www.quickfixengine.org/
    5) UNIX ar Examples: How To Create, View, Extract, Modify C Archive Files (*.a)
    http://www.thegeekstuff.com/2010/08/ar-command-examples/?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed%3A+TheGeekStuff+(The+Geek+Stuff)
	6) Backup and restore X system
	http://tamxuanla.blogspot.com/2015/10/how-to-backup-full-centos-server_22.html
	http://www.centoscn.com/image-text/2013/0418/318.html

------------------------------------------------------------------------------------
VI Commands

    1) remove all white space in a file and replace with a comma
    First delete the blank lines:
    :g/^\s*$/d
    Then use a substitution (:s///) over each line (%) to replace all (g) continuous whitespace (\s\+) with a comma (,)
    :%s/\s\+/,/g

    2) replace character/word in a file
    replace 'foo' with 'bar' in a file
    :%s/foo/bar/g
    replace only whole words exactly match
    :%s/\<foo\>/bar/g

    3) search word and list line number in a file
    :g/word/#

    4) search word in all files under current folder and list them
    :cw | grep -ir word .
	
	5) compare difference between files, this uses vimdiff application
	> vi -d file1 file2 file3
	   you can also use melt which is gui tool
	> meld
	
	6) open/reload .vimrc without leaving current vi
	:split $MYVIMRC
	:source $MYVIMRC

------------------------------------------------------------------------------------
Shell command

    1) find specific file type under directory and count lines in the file
    $ find . -type f -iname *.cpp | xargs wc -l
    $ find . -type f -iname *.cpp -or -iname *.h | xargs wc -l

    2) check system memory, virtual memory usage and configuration
    $ free // Check system memory usage
    $ vmstat // Virtual memory statistics, can be used to see thread interruption & context switch times per second
    $ vmstat -s
    $ swapon -s // Display swap usage by device

    3) display file or file system status
    $ stat

    4) check CPU infromation
    $ lscpu
    $ cat /proc/cpuinfo

    5) key combinations in bash
    Ctrl+A	move cursor to beginning of line
    Ctrl+D	log out of current shell session, equal to 'exit'
    Ctrl+E	move cursor to the end of line
    Ctrl+L	clear this terminal
    Ctrl+U  clear from current pos until beginning of line
    Ctrl+K  clear from current pos to the end of line

    6) show all executable programs with the name
    $ which -a myprogram

    7) check which shell you are using
    $ echo $SHELL
    or
    $ cat /etc/passwd // find your user name line
	
	8) Print the lists of directories and candidate libraries stored in the current cache
	$ ldconfig -p
	$ ldconfig -p | grep /usr/local

------------------------------------------------------------------------------------
tmux

	https://danielmiessler.com/study/tmux/
	http://www.hamvocke.com/blog/a-guide-to-customizing-your-tmux-conf/
	https://gist.github.com/spicycode/1229612
	
	1) with .tmux.conf
	
	// split window vertically
	Ctrl+b v
	// split window horizontally
	Ctrl+b s

	// resize pane
	Ctrl+b J/K/H/L

	// switch/select pane
	Alt J/K/H/L
	Alt arrow

	// switch/select window
	Shift arrow

	2) without .tmux.conf, tmux built-in default commands
	
	// split window into left-right panes
	Ctrl+b %

	// split window into top-bottom panes
	Ctrl+b "

	// navigate panes
	Ctrl+b arrow

	// create new window
	Ctrl+b c

	// go to previous window
	Ctrl+b p

	// go to next window
	Ctrl+b n

	// go to specific window
	Ctrl+b '
	then input the window's index

	// detach a session
	Ctrl+b d

	// list sessions
	Ctrl+b s (works within tmux window)
	tmux ls

	// attach to an existing session
	tmux attach -t number

	// kill a session
	tmux kill-session -t number

------------------------------------------------------------------------------------
GIT

	1) To view which commit(s) have not yet been pushed
	$ git log origin/(branch-name)..
	Or,
	$ git log origin/(branch-name).. --name_status
	Or, add alias to 
	git log origin/$(git name-rev --name-only HEAD).. --name_status
	
	2) add files to commit
	$ git add -A	// stages All
	$ git add .		// stages new and modified, without deleted
	$ git add -u	// stages modified and deleted, without new
	
	3) undo git reset
	http://stackoverflow.com/questions/2510276/undoing-git-reset
	$ git reflog	// list log of all ref updates (e.g., checkout, reset, commit, merge)
	$ git reset 'HEAD@{1}'	// reset to specific commit
	Or,
	$ git reset sha1-hash	// sha1-hash is from ref update list
	
	4) compare file difference 
	$ git diff origin/master -- [local-path]
	Or,
	$ git diff origin/branch-name:remote/path/file.txt  local/path/file.txt
	
	5) view remote branches
	$ git branch -r
	view both local and remote branches
	$ git branch -a
	
	display remote information in general and how it relates to local repository
	$ git remote show origin
	
------------------------------------------------------------------------------------
Valgrind

    // profile tool, performance analysis
    valgrind --tool=callgrind program arg1 arg2
    kcachegrind callgrind.out.$pid
    http://baptiste-wicht.com/posts/2011/09/profile-c-application-with-callgrind-kcachegrind.html

    // detect memory-related errors
    valgrind --leak-check=yes myprog arg1 arg2
    http://valgrind.org/docs/manual/quick-start.html

    // detect multi-thread errors
    valgrind --tool=helgrind myapplication
    http://valgrind.org/docs/manual/hg-manual.html

------------------------------------------------------------------------------------
GDB commands:
    $ set variable i=20
    $ set var i=20
    $ set (i=20)

    $ display i
    $ disp i

	// hardware watchpoints, triggered when the variable changes
    $ watch i 

    $ delete breakpoint

    $ info break
    $ info watch
	
	// to print char array/pointer, use /s (treat variable as string if possible) 
	// char* chArr = "abcd";
	// void* p = chArr;
	$ p /s chArr
	$ p /s (char*)p


    // break when condition is met
    // http://stackoverflow.com/questions/1354637/how-do-i-set-persistent-and-conditional-watchpoints-on-locally-scoped-variables
    $ watch my_var if my_var > 3
    $ break main.c:123 if (var1 == 0)

    // remotely debug with DDD
    http://www.codeproject.com/Articles/14983/Remote-Debugging-using-GDB
	
	// STL support - GDB pretty-printers
	https://www.rethinkdb.com/blog/make-debugging-easier-with-custom-pretty-printers/
	https://sourceware.org/gdb/wiki/STLSupport
	// to print in the old style, use /r (raw)
	$ print /r variable
	
	// Print a description of the type of expression expr. ptype differs from whatis by printing a detailed description, instead of just the name of the type.
	$ ptype expr
	// Show information about the current source file--that is, the source file for the function containing the current point of execution
	$ info source

	// set breakpoint, variable, custom command inside a file and load it either in .gdbinit or on the fly
	https://sourceware.org/gdb/onlinedocs/gdb/Command-Files.html
	
	// Ctrl-C as program is running
	What if the program is running but you forgot to set breakpoints? You can hit CTRL-C and that'll stop the program wherever it happens to be and return you to a "(gdb)" prompt. At that point, you could set up a proper breakpoint somewhere and continue to that breakpoint.
	
	// info
	$ info win  // list opened windows in the layout
	$ focus next // activate next window, or use shortcut Ctrl+x o
	$ fs n
	$ fs SRC	// activate the window SRC
	$ fs CMD	// activate the window CMD
	
	Tui short keys -
	Ctrl+x o // activate next window
	Ctrl+x a // switch between TUI and terminal
	Ctrl+l   // refresh screen
	
	If current activate window is not CMD, use short keys -
	Ctrl+p // show previous command
	Ctrl+n // show next command
	Ctrl+b // move cursor backwards among the command
	Ctrl+f // move cursor forwards among the command

------------------------------------------------------------------------------------
Network commands
    $ ss -s // sockets summary
    $ ss -lp // view open network ports with process name (p)
    $ ss -aplt // view all tcp (t) listening(l) sockets
    $ ss -aplu // view all udp (u) listening(l) sockets
    $ netstat -lnpt // view processes that are listening for tcp (t)
    $ netstat -lnpu // view processes that are listening for udp (t)
    $ ifconfig // can view if multicast is enabled or not
    $ netstat -g // view multicast groups information

------------------------------------------------------------------------------------
Analyze kernel crash
http://www.dedoimedo.com/computers/crash-analyze.html

------------------------------------------------------------------------------------
Trace system calls with strace
    http://linoxide.com/linux-command/linux-strace-command-examples/
    1) trace all system calls
    $ strace ls
    $ strace myprogam arg1 arg2
    2) trace specific system call
    // trace only 'open' system call
    $ strace -e open myprogram arg1 arg2 
    3) trace a process
    $ strace -p processid
    4) summary of system calls, time of execution, errors, etc.
    $ strace -c ls
    $ strace -c myprogram arg1 arg2
    5) this will show you all syscalls the program is doing if your process ID is 12345. 
    // http://unix.stackexchange.com/questions/166541/how-to-know-where-a-program-is-stuck-in-linux
    strace -s 99 -ffp 12345
    6) see calls stack with gdb, bt
    // ftp://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_42.html
    $ sleep 3600 &
      [2] 2621
    $ gdb
    (gdb) attach 2621
    (gdb) bt
    #0  0x00007feda374e6b0 in __nanosleep_nocancel () from /lib64/libc.so.6
    #1  0x0000000000403ee7 in ?? ()
    #2  0x0000000000403d70 in ?? ()
    #3  0x000000000040185d in ?? ()
    #4  0x00007feda36b8b05 in __libc_start_main () from /lib64/libc.so.6
    #5  0x0000000000401969 in ?? ()
    (gdb)

------------------------------------------------------------------------------------
Debug core file
    http://yusufonlinux.blogspot.com/2010/11/debugging-core-using-gdb.html
    Enable core file dump
    http://www.cyberciti.biz/tips/linux-core-dumps.html
    1) Go to /etc/profile.d folder and create a *.sh file such as coredump.sh
    ulimit -c unlimited >/dev/null 2>&1
    2) Edit /etc/sysctl.conf, append the following lines:

    kernel.core_uses_pid = 1
    kernel.core_pattern = /tmp/core-%e-%s-%u-%g-%p-%t
    fs.suid_dumpable = 2

    Where:
    kernel.core_uses_pid = 1 – Appends the coring processes PID to the core file name.
    fs.suid_dumpable = 2 – Make sure you get core dumps for setuid programs.
    kernel.core_pattern = /tmp/core-%e-%s-%u-%g-%p-%t – When the application terminates abnormally, a core file should appear in the /tmp. The kernel.core_pattern sysctl controls exact location of core file. You can define the core file name with the following template whih can contain % specifiers which are substituted by the following values when a core file is created:
    %% – A single % character
    %p – PID of dumped process
    %u – real UID of dumped process
    %g – real GID of dumped process
    %s – number of signal causing dump
    %t – time of dump (seconds since 0:00h, 1 Jan 1970)
    %h – hostname (same as ’nodename’ returned by uname(2))
    %e – executable filename

    3) Reload the settings in /etc/sysctl.conf by running the following command:
    $ sysctl -p

------------------------------------------------------------------------------------
/etc/profile vs. /etc/bashrc, Login vs. non-Login shell, Interactive vs. non-Interactive shell
    http://bencane.com/2013/09/16/understanding-a-little-more-about-etcprofile-and-etcbashrc/
    http://askubuntu.com/questions/247738/why-is-etc-profile-not-invoked-for-non-login-shells

